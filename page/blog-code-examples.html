<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ejemplos de C√≥digo Innovadores - Donkey Kong Classic</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        .article-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .article-header {
            text-align: center;
            margin-bottom: 40px;
        }
        .article-header h1 {
            color: #FFD700;
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        .article-content {
            color: #fff;
            line-height: 1.8;
        }
        .article-content h2 {
            color: #4ECDC4;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        .article-content h3 {
            color: #FF6B6B;
            margin-top: 25px;
            margin-bottom: 10px;
        }
        .code-block {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #4ECDC4;
            overflow-x: auto;
        }
        .code-block pre {
            margin: 0;
            color: #fff;
            font-family: 'Courier New', monospace;
        }
        .innovation-box {
            background: linear-gradient(45deg, rgba(255, 107, 107, 0.1), rgba(78, 205, 196, 0.1));
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border: 2px solid #FFD700;
        }
        .innovation-box h4 {
            color: #FFD700;
            margin-bottom: 10px;
        }
        .highlight {
            background: rgba(255, 215, 0, 0.2);
            padding: 2px 5px;
            border-radius: 3px;
        }
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 25px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }
        .back-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    <a href="blog.html" class="back-button">‚Üê Volver al Blog</a>
    
    <div class="article-container">
        <div class="article-header">
            <h1>üíª Ejemplos de C√≥digo Innovadores</h1>
            <p>Showcase de las soluciones m√°s interesantes generadas por IA</p>
        </div>

        <div class="article-content">
            <h2>Sistema de IA H√≠brido</h2>
            <p><span class="highlight">Desaf√≠o:</span> Crear enemigos inteligentes que sean desafiantes pero predecibles.</p>
            <p><span class="highlight">Soluci√≥n de IA:</span> Sistema h√≠brido que combina l√≥gica basada en reglas con validaci√≥n Q-Learning.</p>

            <div class="code-block">
                <pre>def barrel_movement(self, platforms, player_rect=None):
    """IA H√≠brida: Decisiones primarias basadas en reglas con validaci√≥n Q-Learning"""
    if not player_rect or not platforms:
        self.velocity_x = self.speed * self.direction
        return
    
    # PASO 1: Decisi√≥n primaria basada en reglas
    dx = player_rect.centerx - self.rect.centerx
    dy = player_rect.centery - self.rect.centery
    primary_action = self.decide_primary_action(dx, dy, current_platform, player_platform)
    
    # PASO 2: Validaci√≥n y mejora con Q-Learning
    if hasattr(self, 'ai_agent'):
        state = self.get_state(player_rect)
        q_action = self.ai_agent.choose_action(state)
        
        # Anular solo en situaciones espec√≠ficas
        if self.should_override_action(primary_action, q_action, dx, dy):
            primary_action = q_action
        
        # Aprender de la acci√≥n tomada
        reward = self.calculate_reward(player_rect)
        next_state = self.get_state(player_rect)
        self.ai_agent.learn(state, primary_action, reward, next_state, not self.active)
    
    # PASO 3: Ejecutar la acci√≥n decidida
    self.execute_action_decision(primary_action, current_platform, dx)</pre>
            </div>

            <div class="innovation-box">
                <h4>Por qu√© esto es Innovador:</h4>
                <ul>
                    <li><strong>Lo mejor de ambos mundos:</strong> Comportamiento base predecible con mejoras adaptativas</li>
                    <li><strong>Aprendizaje contextual:</strong> Q-Learning solo anula cuando tiene alta confianza</li>
                    <li><strong>Experiencia del jugador:</strong> Mantiene la sensaci√≥n del juego mientras agrega inteligencia</li>
                    <li><strong>Amigable para debugging:</strong> El n√∫cleo basado en reglas es f√°cil de entender y modificar</li>
                </ul>
            </div>

            <h2>Carga Din√°mica de Assets</h2>
            <p><span class="highlight">Desaf√≠o:</span> Assets que no cargan en ejecutables empaquetados debido a diferencias de rutas.</p>
            <p><span class="highlight">Soluci√≥n de IA:</span> Resoluci√≥n din√°mica de rutas que funciona tanto en desarrollo como en producci√≥n.</p>

            <div class="code-block">
                <pre>def load_sprites(self):
    """Carga din√°mica de assets para desarrollo y ejecutables empaquetados"""
    sprites = {'idle': [], 'jump': []}
    
    # PASO 1: Determinar la ruta base correcta
    if hasattr(sys, '_MEIPASS'):
        # Ejecutable empaquetado con PyInstaller
        base_path = sys._MEIPASS
        print("Cargando assets desde ejecutable empaquetado")
    else:
        # Entorno de desarrollo
        base_path = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
        print("Cargando assets desde directorio de desarrollo")
    
    # PASO 2: Cargar sprites con manejo comprensivo de errores
    for i in range(1, 12):
        sprite_path = os.path.join(base_path, 'assets', 'player', f'sprite_{i:02d}.png')
        
        if os.path.exists(sprite_path):
            try:
                sprite = pygame.image.load(sprite_path)
                sprite = pygame.transform.scale(sprite, (self.rect.width, self.rect.height))
                sprites['jump'].append(sprite)
                print(f"‚úì Sprite cargado: sprite_{i:02d}.png")
            except Exception as e:
                print(f"‚úó Error cargando sprite {sprite_path}: {e}")
                # Continuar cargando otros sprites
        else:
            print(f"‚ö† Sprite no encontrado: {sprite_path}")
    
    return sprites if any(sprites.values()) else None

def load_asset_safely(self, asset_path, default_size=(32, 32)):
    """Carga segura de assets con fallback"""
    try:
        if os.path.exists(asset_path):
            asset = pygame.image.load(asset_path)
            return pygame.transform.scale(asset, default_size)
    except Exception as e:
        print(f"Fall√≥ la carga de asset para {asset_path}: {e}")
    
    # Retornar rect√°ngulo coloreado como fallback
    surface = pygame.Surface(default_size)
    surface.fill((255, 0, 255))  # Magenta para assets faltantes
    return surface</pre>
            </div>

            <div class="innovation-box">
                <h4>Por qu√© esto es Innovador:</h4>
                <ul>
                    <li><strong>Compatibilidad universal:</strong> Funciona en desarrollo y ejecutables empaquetados</li>
                    <li><strong>Degradaci√≥n elegante:</strong> Contin√∫a funcionando incluso con assets faltantes</li>
                    <li><strong>Logging detallado:</strong> Proporciona retroalimentaci√≥n clara sobre el estado de carga de assets</li>
                    <li><strong>Sistema de fallback:</strong> Nunca crashea debido a assets faltantes</li>
                </ul>
            </div>

            <h2>Spawn Inteligente de Enemigos</h2>
            <p><span class="highlight">Desaf√≠o:</span> Equilibrar la dificultad de enemigos sin abrumar al jugador.</p>
            <p><span class="highlight">Soluci√≥n de IA:</span> Sistema de spawn adaptativo que escala con el tiempo y rendimiento del jugador.</p>

            <div class="code-block">
                <pre>def spawn_entities(self):
    """Spawn inteligente de entidades con dificultad adaptativa"""
    self.spawn_timer += 1
    
    # SPAWN ADAPTATIVO DE BARRILES
    self.spawn_barrels_adaptively()
    
    # SPAWN GRADUAL DE MONSTRUOS
    self.spawn_monsters_gradually()

def spawn_barrels_adaptively(self):
    """Spawn de barriles con dificultad creciente en el tiempo"""
    barrel_count = len([e for e in self.enemies if e.enemy_type == "barrel"])
    
    # Calcular m√°ximo de barriles basado en tiempo jugado
    time_factor = self.spawn_timer // 3600  # Cada 60 segundos
    max_barrels = min(1 + time_factor, 3)  # M√°ximo 3 barriles
    
    # Calcular tasa de spawn (aumenta con el tiempo)
    current_spawn_rate = min(
        self.base_spawn_rate + (time_factor * self.spawn_rate_increase),
        self.max_spawn_rate
    )
    
    # Spawn si est√° bajo el l√≠mite y pasa la verificaci√≥n de probabilidad
    if barrel_count < max_barrels and random.random() < current_spawn_rate:
        self.spawn_barrel()
        print(f"Barril spawneado (Tasa: {current_spawn_rate:.3f}, Cantidad: {barrel_count + 1}/{max_barrels})")

def spawn_barrel(self):
    """Spawn de barril en ubicaci√≥n estrat√©gica"""
    # Elegir punto de spawn basado en posici√≥n del jugador
    spawn_points = [(50, 100), (self.config.WINDOW_WIDTH - 50, 100)]
    
    # Preferir punto de spawn m√°s lejos del jugador
    if hasattr(self, 'player') and self.player:
        player_x = self.player.rect.centerx
        if player_x < self.config.WINDOW_WIDTH / 2:
            spawn_point = spawn_points[1]  # Spawn a la derecha
        else:
            spawn_point = spawn_points[0]  # Spawn a la izquierda
    else:
        spawn_point = random.choice(spawn_points)
    
    new_enemy = Enemy(spawn_point[0], spawn_point[1], self.config, "barrel")
    self.enemies.append(new_enemy)</pre>
            </div>

            <div class="innovation-box">
                <h4>Por qu√© esto es Innovador:</h4>
                <ul>
                    <li><strong>Dificultad adaptativa:</strong> La tasa de spawn aumenta con el tiempo jugado</li>
                    <li><strong>Posicionamiento estrat√©gico:</strong> Los enemigos aparecen lejos del jugador para mejor desaf√≠o</li>
                    <li><strong>Progresi√≥n equilibrada:</strong> El aumento gradual previene abrumar</li>
                    <li><strong>Monitoreo de rendimiento:</strong> Estad√≠sticas integradas para ajustes</li>
                </ul>
            </div>

            <h2>Sistema de Pausa Adaptativo</h2>
            <p><span class="highlight">Desaf√≠o:</span> Hacer enemigos menos predecibles sin hacerlos injustos.</p>
            <p><span class="highlight">Soluci√≥n de IA:</span> Sistema de pausa din√°mico que disminuye con el tiempo, haciendo enemigos m√°s agresivos.</p>

            <div class="code-block">
                <pre>def handle_pause_behavior(self):
    """Sistema de pausa din√°mico que se adapta con el tiempo"""
    self.pause_timer += 1
    
    if self.is_paused:
        # Contar tiempo de pausa
        if self.pause_timer >= self.pause_duration:
            self.is_paused = False
            self.pause_timer = 0
            
            # ELEMENTO ADAPTATIVO: Reducir duraci√≥n de pausa para la pr√≥xima vez
            self.pause_duration = max(
                self.min_pause_duration,
                self.pause_duration - self.pause_reduction
            )
            
            print(f"Enemigo reanudado, pr√≥xima pausa ser√° de {self.pause_duration} frames")
    else:
        # Verificar si es hora de pausar
        if self.pause_timer >= self.pause_cycle:
            self.is_paused = True
            self.pause_timer = 0
            print(f"Enemigo pausado por {self.pause_duration} frames")

def get_pause_statistics(self):
    """Obtener estad√≠sticas actuales del sistema de pausa"""
    return {
        'current_pause_duration': self.pause_duration,
        'min_pause_duration': self.min_pause_duration,
        'is_currently_paused': self.is_paused,
        'pause_reduction_per_cycle': self.pause_reduction,
        'aggressiveness_level': 1 - (self.pause_duration / 60)  # Escala 0-1
    }</pre>
            </div>

            <div class="innovation-box">
                <h4>Por qu√© esto es Innovador:</h4>
                <ul>
                    <li><strong>Dificultad emergente:</strong> Los enemigos naturalmente se vuelven m√°s agresivos con el tiempo</li>
                    <li><strong>Adaptaci√≥n del jugador:</strong> Da tiempo a los jugadores para aprender, luego aumenta el desaf√≠o</li>
                    <li><strong>Progresi√≥n suave:</strong> El cambio gradual se siente natural, no brusco</li>
                    <li><strong>Configurable:</strong> F√°cil de ajustar para diferentes curvas de dificultad</li>
                </ul>
            </div>

            <h2>Automatizaci√≥n Robusta de Build</h2>
            <p><span class="highlight">Desaf√≠o:</span> Crear un sistema de build que maneje todos los casos edge y diferencias de plataforma.</p>
            <p><span class="highlight">Soluci√≥n de IA:</span> Automatizaci√≥n comprensiva de build con manejo de errores y reportes.</p>

            <div class="code-block">
                <pre>def build_game():
    """Sistema robusto de build con manejo comprensivo de errores"""
    print("Iniciando proceso de build...")
    
    # PASO 1: Detectar disponibilidad de PyInstaller
    pyinstaller_cmd = detect_pyinstaller_command()
    if not pyinstaller_cmd:
        print("‚úó PyInstaller no disponible")
        return False
    
    # PASO 2: Build con captura de errores
    final_cmd = build_command(pyinstaller_cmd)
    
    try:
        print(f"Ejecutando: {' '.join(final_cmd)}")
        result = subprocess.run(
            final_cmd, 
            check=True, 
            capture_output=True, 
            text=True,
            timeout=300  # Timeout de 5 minutos
        )
        print("‚úì Build completado exitosamente")
        return True
        
    except subprocess.TimeoutExpired:
        print("‚úó Build expir√≥ despu√©s de 5 minutos")
        return False
    except subprocess.CalledProcessError as e:
        print(f"‚úó Build fall√≥ con c√≥digo de salida: {e.returncode}")
        analyze_build_error(e.stdout, e.stderr)
        return False
    except Exception as e:
        print(f"‚úó Error inesperado de build: {e}")
        return False

def analyze_build_error(stdout, stderr):
    """Analizar errores de build y proporcionar sugerencias √∫tiles"""
    error_patterns = {
        "No module named": "Dependencia faltante - verificar requirements.txt",
        "Permission denied": "Problema de permisos - intentar ejecutar como administrador",
        "Unable to find": "Archivo faltante - verificar si todos los assets est√°n presentes",
        "Memory error": "Memoria insuficiente - intentar cerrar otras aplicaciones",
        "CPU dispatcher": "Conflicto NumPy - verificar compatibilidad de versi√≥n NumPy"
    }
    
    combined_output = f"{stdout}\n{stderr}".lower()
    
    print("\nüîç An√°lisis de Error:")
    for pattern, suggestion in error_patterns.items():
        if pattern.lower() in combined_output:
            print(f"  ‚Ä¢ {pattern}: {suggestion}")
    
    print(f"\nüìã Salida Completa de Error:")
    if stdout:
        print(f"STDOUT:\n{stdout}")
    if stderr:
        print(f"STDERR:\n{stderr}")</pre>
            </div>

            <div class="innovation-box">
                <h4>Por qu√© esto es Innovador:</h4>
                <ul>
                    <li><strong>Detecci√≥n inteligente:</strong> Encuentra autom√°ticamente la forma correcta de ejecutar PyInstaller</li>
                    <li><strong>An√°lisis comprensivo de errores:</strong> Proporciona sugerencias espec√≠ficas para problemas comunes</li>
                    <li><strong>Protecci√≥n de timeout:</strong> Previene builds colgados</li>
                    <li><strong>Sistema de validaci√≥n:</strong> Asegura que el build realmente funcion√≥</li>
                    <li><strong>Soporte al usuario:</strong> Crea documentaci√≥n y ayudas de instalaci√≥n</li>
                </ul>
            </div>

            <h2>Q-Learning sin NumPy</h2>
            <p><span class="highlight">Desaf√≠o:</span> Conflictos de PyInstaller con NumPy causando errores de empaquetado.</p>
            <p><span class="highlight">Soluci√≥n de IA:</span> Implementaci√≥n de Q-Learning usando solo Python est√°ndar.</p>

            <div class="code-block">
                <pre>class SimpleArray:
    """Reemplazo simple de NumPy para empaquetado"""
    def __init__(self, data):
        self.data = data if isinstance(data, list) else [data]
    
    def argmax(self):
        """Encuentra el √≠ndice del valor m√°ximo"""
        if not self.data:
            return 0
        max_val = max(self.data)
        return self.data.index(max_val)
    
    def zeros(self, shape):
        """Crea array de ceros"""
        if isinstance(shape, int):
            return [0.0] * shape
        return [[0.0] * shape[1] for _ in range(shape[0])]

class QLearningAgent:
    def __init__(self, state_size, action_size, learning_rate=0.1):
        self.state_size = state_size
        self.action_size = action_size
        self.learning_rate = learning_rate
        self.discount_factor = 0.95
        self.epsilon = 0.1
        self.q_table = {}
    
    def choose_action(self, state):
        """Selecci√≥n de acci√≥n epsilon-greedy sin NumPy"""
        state_key = self.get_state_key(state)
        
        if random.random() < self.epsilon:
            return random.randint(0, self.action_size - 1)
        
        if state_key not in self.q_table:
            self.q_table[state_key] = [0.0] * self.action_size
        
        # Usar implementaci√≥n manual de argmax
        q_values = self.q_table[state_key]
        max_value = max(q_values)
        return q_values.index(max_value)</pre>
            </div>

            <div class="innovation-box">
                <h4>Por qu√© esto es Innovador:</h4>
                <ul>
                    <li><strong>Soluci√≥n de compatibilidad:</strong> Elimina conflictos de dependencias de PyInstaller</li>
                    <li><strong>Rendimiento mantenido:</strong> Funcionalidad completa sin bibliotecas externas</li>
                    <li><strong>Simplicidad:</strong> M√°s f√°cil de debuggear y entender</li>
                    <li><strong>Portabilidad:</strong> Funciona en cualquier instalaci√≥n de Python</li>
                </ul>
            </div>

            <h2>Conclusi√≥n</h2>
            <p>Estos ejemplos demuestran c√≥mo la IA puede generar c√≥digo sofisticado y listo para producci√≥n que maneja la complejidad del mundo real y casos edge de manera efectiva. Las soluciones van m√°s all√° de la funcionalidad b√°sica para incluir:</p>

            <ul>
                <li><strong>Manejo robusto de errores</strong></li>
                <li><strong>Degradaci√≥n elegante</strong></li>
                <li><strong>Adaptabilidad inteligente</strong></li>
                <li><strong>Compatibilidad multiplataforma</strong></li>
                <li><strong>Experiencia de usuario optimizada</strong></li>
            </ul>

            <p>La clave est√° en proporcionar contexto rico y requerimientos espec√≠ficos a la IA, permiti√©ndole generar soluciones que no solo funcionan, sino que son mantenibles, extensibles y profesionales.</p>
        </div>
    </div>
</body>
</html>